'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var React = require('react');
var PropTypes = require('prop-types');
var descendants = require('@reach/descendants');
var utils = require('@reach/utils');
var autoId = require('@reach/auto-id');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

var React__default = /*#__PURE__*/_interopDefaultLegacy(React);
var PropTypes__default = /*#__PURE__*/_interopDefaultLegacy(PropTypes);

function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;

  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }

  return target;
}

var TabsDescendantsContext = /*#__PURE__*/descendants.createDescendantContext("TabsDescendantsContext");
var TabPanelDescendantsContext = /*#__PURE__*/descendants.createDescendantContext("TabPanelDescendantsContext");
var TabsContext = /*#__PURE__*/utils.createNamedContext("TabsContext", {});

(function (TabsKeyboardActivation) {
  TabsKeyboardActivation["Auto"] = "auto";
  TabsKeyboardActivation["Manual"] = "manual";
})(exports.TabsKeyboardActivation || (exports.TabsKeyboardActivation = {}));

(function (TabsOrientation) {
  TabsOrientation["Horizontal"] = "horizontal";
  TabsOrientation["Vertical"] = "vertical";
})(exports.TabsOrientation || (exports.TabsOrientation = {})); ////////////////////////////////////////////////////////////////////////////////

/**
 * Tabs
 *
 * The parent component of the tab interface.
 *
 * @see Docs https://reach.tech/tabs#tabs
 */


var Tabs = /*#__PURE__*/utils.forwardRefWithAs(function Tabs(_ref, ref) {
  var _props$id;

  var _ref$as = _ref.as,
      Comp = _ref$as === void 0 ? "div" : _ref$as,
      children = _ref.children,
      defaultIndex = _ref.defaultIndex,
      _ref$orientation = _ref.orientation,
      orientation = _ref$orientation === void 0 ? exports.TabsOrientation.Horizontal : _ref$orientation,
      _ref$index = _ref.index,
      controlledIndex = _ref$index === void 0 ? undefined : _ref$index,
      _ref$keyboardActivati = _ref.keyboardActivation,
      keyboardActivation = _ref$keyboardActivati === void 0 ? exports.TabsKeyboardActivation.Auto : _ref$keyboardActivati,
      onChange = _ref.onChange,
      _ref$readOnly = _ref.readOnly,
      readOnly = _ref$readOnly === void 0 ? false : _ref$readOnly,
      props = _objectWithoutPropertiesLoose(_ref, ["as", "children", "defaultIndex", "orientation", "index", "keyboardActivation", "onChange", "readOnly"]);

  var isControlled = React.useRef(controlledIndex != null);
  utils.useControlledSwitchWarning(controlledIndex, "index", "Tabs");

  var _id = autoId.useId(props.id);

  var id = (_props$id = props.id) !== null && _props$id !== void 0 ? _props$id : utils.makeId("tabs", _id); // We only manage focus if the user caused the update vs. a new controlled
  // index coming in.

  var userInteractedRef = React.useRef(false);
  var selectedPanelRef = React.useRef(null);
  var isRTL = React.useRef(false);

  var _useControlledState = utils.useControlledState(controlledIndex, defaultIndex !== null && defaultIndex !== void 0 ? defaultIndex : 0),
      selectedIndex = _useControlledState[0],
      setSelectedIndex = _useControlledState[1];

  var _useState = React.useState(-1),
      focusedIndex = _useState[0],
      setFocusedIndex = _useState[1];

  var _useDescendantsInit = descendants.useDescendantsInit(),
      tabs = _useDescendantsInit[0],
      setTabs = _useDescendantsInit[1];

  var context = React.useMemo(function () {
    return {
      focusedIndex: focusedIndex,
      id: id,
      isControlled: isControlled.current,
      isRTL: isRTL,
      keyboardActivation: keyboardActivation,
      onFocusPanel: function onFocusPanel() {
        if (selectedPanelRef.current && utils.isFunction(selectedPanelRef.current.focus)) {
          selectedPanelRef.current.focus();
        }
      },
      onSelectTab: readOnly ? utils.noop : function (index) {
        userInteractedRef.current = true;
        onChange && onChange(index);
        setSelectedIndex(index);
      },
      onSelectTabWithKeyboard: readOnly ? utils.noop : function (index) {
        userInteractedRef.current = true;

        switch (keyboardActivation) {
          case exports.TabsKeyboardActivation.Manual:
            var tabElement = tabs[index] && tabs[index].element;

            if (tabElement && utils.isFunction(tabElement.focus)) {
              tabElement.focus();
            }

            return;

          case exports.TabsKeyboardActivation.Auto:
          default:
            onChange && onChange(index);
            setSelectedIndex(index);
            return;
        }
      },
      orientation: orientation,
      selectedIndex: selectedIndex,
      selectedPanelRef: selectedPanelRef,
      setFocusedIndex: setFocusedIndex,
      setSelectedIndex: setSelectedIndex,
      userInteractedRef: userInteractedRef
    };
  }, [focusedIndex, id, keyboardActivation, onChange, orientation, readOnly, selectedIndex, setSelectedIndex, tabs]);
  React.useEffect(function () {
    return utils.checkStyles("tabs");
  }, []);
  return React__default['default'].createElement(descendants.DescendantProvider, {
    context: TabsDescendantsContext,
    items: tabs,
    set: setTabs
  }, React__default['default'].createElement(TabsContext.Provider, {
    value: context
  }, React__default['default'].createElement(Comp, Object.assign({}, props, {
    ref: ref,
    "data-reach-tabs": "",
    "data-orientation": orientation,
    id: props.id
  }), utils.isFunction(children) ? children({
    focusedIndex: focusedIndex,
    id: id,
    selectedIndex: selectedIndex
  }) : children)));
});

{
  Tabs.displayName = "Tabs";
  Tabs.propTypes = {
    children: PropTypes__default['default'].node.isRequired,
    onChange: PropTypes__default['default'].func,
    orientation: /*#__PURE__*/PropTypes__default['default'].oneOf( /*#__PURE__*/Object.values(exports.TabsOrientation)),
    index: function index(props, name, compName, location, propName) {
      var val = props[name];

      if (props.index > -1 && props.onChange == null && props.readOnly !== true) {
        return new Error("You provided a value prop to `" + compName + "` without an `onChange` handler. This will render a read-only tabs element. If the tabs should be mutable use `defaultIndex`. Otherwise, set `onChange`.");
      } else if (val != null && !utils.isNumber(val)) {
        return new Error("Invalid prop `" + propName + "` supplied to `" + compName + "`. Expected `number`, received `" + (Array.isArray(val) ? "array" : typeof val) + "`.");
      }

      return null;
    },
    defaultIndex: PropTypes__default['default'].number
  };
} ////////////////////////////////////////////////////////////////////////////////

/**
 * TabList
 *
 * The parent component of the tabs.
 *
 * @see Docs https://reach.tech/tabs#tablist
 */


var TabListImpl = /*#__PURE__*/utils.forwardRefWithAs(function TabList(_ref2, forwardedRef) {
  var children = _ref2.children,
      _ref2$as = _ref2.as,
      Comp = _ref2$as === void 0 ? "div" : _ref2$as,
      onKeyDown = _ref2.onKeyDown,
      props = _objectWithoutPropertiesLoose(_ref2, ["children", "as", "onKeyDown"]);

  var _useContext = React.useContext(TabsContext),
      focusedIndex = _useContext.focusedIndex,
      isControlled = _useContext.isControlled,
      isRTL = _useContext.isRTL,
      keyboardActivation = _useContext.keyboardActivation,
      onSelectTabWithKeyboard = _useContext.onSelectTabWithKeyboard,
      orientation = _useContext.orientation,
      selectedIndex = _useContext.selectedIndex,
      setSelectedIndex = _useContext.setSelectedIndex;

  var tabs = descendants.useDescendants(TabsDescendantsContext);
  var ownRef = React.useRef(null);
  var ref = utils.useForkedRef(forwardedRef, ownRef);
  React.useEffect(function () {
    if (ownRef.current && (ownRef.current.ownerDocument && ownRef.current.ownerDocument.dir === "rtl" || utils.getElementComputedStyle(ownRef.current, "direction") === "rtl")) {
      isRTL.current = true;
    }
  }, [isRTL]);
  var handleKeyDown = utils.useEventCallback(utils.wrapEvent(onKeyDown, descendants.useDescendantKeyDown(TabsDescendantsContext, {
    currentIndex: keyboardActivation === exports.TabsKeyboardActivation.Manual ? focusedIndex : selectedIndex,
    orientation: orientation,
    rotate: true,
    callback: onSelectTabWithKeyboard,
    filter: function filter(tab) {
      return !tab.disabled;
    },
    rtl: isRTL.current
  })));
  utils.useIsomorphicLayoutEffect(function () {
    var _tabs$selectedIndex;

    // In the event an uncontrolled component's selected index is disabled,
    // (this should only happen if the first tab is disabled and no default
    // index is set), we need to override the selection to the next selectable
    // index value.
    if (!isControlled && utils.boolOrBoolString((_tabs$selectedIndex = tabs[selectedIndex]) === null || _tabs$selectedIndex === void 0 ? void 0 : _tabs$selectedIndex.disabled)) {
      var next = tabs.find(function (tab) {
        return !tab.disabled;
      });

      if (next) {
        setSelectedIndex(next.index);
      }
    }
  }, [tabs, isControlled, selectedIndex, setSelectedIndex]);
  return React__default['default'].createElement(Comp // The element that serves as the container for the set of tabs has role
  // `tablist`
  // https://www.w3.org/TR/wai-aria-practices-1.2/#tabpanel
  , Object.assign({
    // The element that serves as the container for the set of tabs has role
    // `tablist`
    // https://www.w3.org/TR/wai-aria-practices-1.2/#tabpanel
    role: "tablist",
    "aria-orientation": orientation
  }, props, {
    "data-reach-tab-list": "",
    ref: ref,
    onKeyDown: handleKeyDown
  }), React.Children.map(children, function (child, index) {
    // TODO: Remove in 1.0
    return utils.cloneValidElement(child, {
      isSelected: index === selectedIndex
    });
  }));
});

{
  TabListImpl.displayName = "TabList";
  TabListImpl.propTypes = {
    as: PropTypes__default['default'].any,
    children: PropTypes__default['default'].node
  };
}

var TabList = /*#__PURE__*/utils.memoWithAs(TabListImpl);

{
  TabList.displayName = "TabList";
}

/**
 * Tab
 *
 * The interactive element that changes the selected panel.
 *
 * @see Docs https://reach.tech/tabs#tab
 */

var Tab = /*#__PURE__*/utils.forwardRefWithAs(function Tab(_ref3, forwardedRef) {
  var children = _ref3.children,
      _ = _ref3.isSelected,
      _ref3$as = _ref3.as,
      Comp = _ref3$as === void 0 ? "button" : _ref3$as,
      indexProp = _ref3.index,
      disabled = _ref3.disabled,
      onBlur = _ref3.onBlur,
      onFocus = _ref3.onFocus,
      props = _objectWithoutPropertiesLoose(_ref3, ["children", "isSelected", "as", "index", "disabled", "onBlur", "onFocus"]);

  var _useContext2 = React.useContext(TabsContext),
      tabsId = _useContext2.id,
      onSelectTab = _useContext2.onSelectTab,
      orientation = _useContext2.orientation,
      selectedIndex = _useContext2.selectedIndex,
      userInteractedRef = _useContext2.userInteractedRef,
      setFocusedIndex = _useContext2.setFocusedIndex;

  var ownRef = React.useRef(null);
  var ref = utils.useForkedRef(forwardedRef, ownRef);
  var index = descendants.useDescendant({
    element: ownRef.current,
    disabled: !!disabled
  }, TabsDescendantsContext, indexProp);
  var htmlType = Comp === "button" && props.type == null ? "button" : props.type;
  var isSelected = index === selectedIndex;

  function onSelect() {
    onSelectTab(index);
  }

  utils.useUpdateEffect(function () {
    if (isSelected && ownRef.current && userInteractedRef.current) {
      userInteractedRef.current = false;

      if (utils.isFunction(ownRef.current.focus)) {
        ownRef.current.focus();
      }
    }
  }, [isSelected, userInteractedRef]);
  var handleFocus = utils.useEventCallback(utils.wrapEvent(onFocus, function () {
    setFocusedIndex(index);
  }));
  var handleBlur = utils.useEventCallback(utils.wrapEvent(onBlur, function () {
    setFocusedIndex(-1);
  }));
  return React__default['default'].createElement(Comp // Each element with role `tab` has the property `aria-controls` referring
  // to its associated `tabpanel` element.
  // https://www.w3.org/TR/wai-aria-practices-1.2/#tabpanel
  , Object.assign({
    "aria-controls": utils.makeId(tabsId, "panel", index),
    "aria-disabled": disabled,
    "aria-selected": isSelected,
    // Each element that serves as a tab has role `tab` and is contained
    // within the element with role `tablist`.
    // https://www.w3.org/TR/wai-aria-practices-1.2/#tabpanel
    role: "tab",
    tabIndex: isSelected ? 0 : -1
  }, props, {
    ref: ref,
    "data-reach-tab": "",
    "data-orientation": orientation,
    "data-selected": isSelected ? "" : undefined,
    disabled: disabled,
    id: utils.makeId(tabsId, "tab", index),
    onClick: onSelect,
    onFocus: handleFocus,
    onBlur: handleBlur,
    type: htmlType
  }), children);
});

{
  Tab.displayName = "Tab";
  Tab.propTypes = {
    children: PropTypes__default['default'].node,
    disabled: PropTypes__default['default'].bool
  };
} ////////////////////////////////////////////////////////////////////////////////

/**
 * TabPanels
 *
 * The parent component of the panels.
 *
 * @see Docs https://reach.tech/tabs#tabpanels
 */


var TabPanelsImpl = /*#__PURE__*/utils.forwardRefWithAs(function TabPanels(_ref4, forwardedRef) {
  var children = _ref4.children,
      _ref4$as = _ref4.as,
      Comp = _ref4$as === void 0 ? "div" : _ref4$as,
      props = _objectWithoutPropertiesLoose(_ref4, ["children", "as"]);

  var ownRef = React.useRef();
  var ref = utils.useForkedRef(ownRef, forwardedRef);

  var _useDescendantsInit2 = descendants.useDescendantsInit(),
      tabPanels = _useDescendantsInit2[0],
      setTabPanels = _useDescendantsInit2[1];

  return React__default['default'].createElement(descendants.DescendantProvider, {
    context: TabPanelDescendantsContext,
    items: tabPanels,
    set: setTabPanels
  }, React__default['default'].createElement(Comp, Object.assign({}, props, {
    ref: ref,
    "data-reach-tab-panels": ""
  }), children));
});

{
  TabPanelsImpl.displayName = "TabPanels";
  TabPanelsImpl.propTypes = {
    as: PropTypes__default['default'].any,
    children: PropTypes__default['default'].node
  };
}

var TabPanels = /*#__PURE__*/utils.memoWithAs(TabPanelsImpl);

{
  TabPanels.displayName = "TabPanels";
}

/**
 * TabPanel
 *
 * The panel that displays when it's corresponding tab is active.
 *
 * @see Docs https://reach.tech/tabs#tabpanel
 */

var TabPanel = /*#__PURE__*/utils.forwardRefWithAs(function TabPanel(_ref5, forwardedRef) {
  var children = _ref5.children,
      ariaLabel = _ref5["aria-label"],
      _ref5$as = _ref5.as,
      Comp = _ref5$as === void 0 ? "div" : _ref5$as,
      props = _objectWithoutPropertiesLoose(_ref5, ["children", "aria-label", "as"]);

  var _useContext3 = React.useContext(TabsContext),
      selectedPanelRef = _useContext3.selectedPanelRef,
      selectedIndex = _useContext3.selectedIndex,
      tabsId = _useContext3.id;

  var ownRef = React.useRef(null);
  var index = descendants.useDescendant({
    element: ownRef.current
  }, TabPanelDescendantsContext);
  var id = utils.makeId(tabsId, "panel", index); // Because useDescendant will always return -1 on the first render,
  // `isSelected` will briefly be false for all tabs. We set a tab panel's
  // hidden attribute based `isSelected` being false, meaning that all tabs
  // are initially hidden. This makes it impossible for consumers to do
  // certain things, like focus an element inside the active tab panel when
  // the page loads. So what we can do is track that a panel is "ready" to be
  // hidden once effects are run (descendants work their magic in
  // useLayoutEffect, so we can set our ref in useEffecct to run later). We
  // can use a ref instead of state because we're always geting a re-render
  // anyway thanks to descendants. This is a little more coupled to the
  // implementation details of descendants than I'd like, but we'll add a test
  // to (hopefully) catch any regressions.

  var isSelected = index === selectedIndex;
  var readyToHide = React.useRef(false);
  var hidden = readyToHide.current ? !isSelected : false;
  React__default['default'].useEffect(function () {
    readyToHide.current = true;
  }, []);
  var ref = utils.useForkedRef(forwardedRef, ownRef, isSelected ? selectedPanelRef : null);
  return React__default['default'].createElement(Comp // Each element with role `tabpanel` has the property `aria-labelledby`
  // referring to its associated tab element.
  , Object.assign({
    "aria-labelledby": utils.makeId(tabsId, "tab", index),
    hidden: hidden,
    // Each element that contains the content panel for a tab has role
    // `tabpanel`.
    // https://www.w3.org/TR/wai-aria-practices-1.2/#tabpanel
    role: "tabpanel",
    tabIndex: isSelected ? 0 : -1
  }, props, {
    ref: ref,
    "data-reach-tab-panel": "",
    id: id
  }), children);
});

{
  TabPanel.displayName = "TabPanel";
  TabPanel.propTypes = {
    as: PropTypes__default['default'].any,
    children: PropTypes__default['default'].node
  };
} ////////////////////////////////////////////////////////////////////////////////

/**
 * A hook that exposes data for a given `Tabs` component to its descendants.
 *
 * @see Docs https://reach.tech/tabs#usetabscontext
 */


function useTabsContext() {
  var _useContext4 = React.useContext(TabsContext),
      focusedIndex = _useContext4.focusedIndex,
      id = _useContext4.id,
      selectedIndex = _useContext4.selectedIndex;

  return React.useMemo(function () {
    return {
      focusedIndex: focusedIndex,
      id: id,
      selectedIndex: selectedIndex
    };
  }, [focusedIndex, id, selectedIndex]);
}

exports.Tab = Tab;
exports.TabList = TabList;
exports.TabPanel = TabPanel;
exports.TabPanels = TabPanels;
exports.Tabs = Tabs;
exports.useTabsContext = useTabsContext;
//# sourceMappingURL=tabs.cjs.development.js.map
